HLD topics ðŸ”¥ ðŸ”¥ :
-----------------------------
https://www.youtube.com/playlist?list=PL6W8uoQQ2c63W58rpNFDwdrBnq5G3EfT7
------------------------------
Learn About Network Protocols (TCP, Websocket, HTTP etc.)
Client-Server Vs Peer 2 Peer Architecture
C.A.P Theorem
Microservices Imp. Design Patterns (SAGA pattern, Strangler Pattern)
Scale from 0 to Million Users
Design Consistent Hashing
Design URL Shortening
Back of the Envelope Estimation
Design Key-Value Store
SQL vs NoSQL, When to Use Which DB
Design WhatsApp
Design Rate Limiter
Design Search Autocomplete System / Typeahead System
Understand Message Queue , Kafka etc.
What is Proxy Servers
What is CDN
Storage types: 
(Block Storage, File Storage, Object Storage (S3) , RAID)
File System 
(Google File System, HDFS)
Bloom Filter
Merkle Tree , Gossiping Protocol
Caching
(Cache Invalidation, Cache eviction)
How to Scale Database
- Sharding (Horizontal and Vertical)
- Partitioning
- Replication, Mirroring
- Leader Election
- Indexing etc.
Design Notification System
Design Pastebin
Design Twitter
Design Dropbox
Design Instagram
Design YouTube
Design Google Drive
Design Web Crawler
Design Facebook News Feed / Newsfeed System 
Design Ticket Master
Design NearByFriends or Yelp


1. Understand the functional and non-functional requirements before designing.
2. Clearly define the use cases and constraints of the system.
3. There is no perfect solution. Itâ€™s all about tradeoffs.
4. Assume requirements will change and design the system to be flexible.
5. Assume everything can and will fail. Make it fault tolerant.
6. Don't add functionality until it's necessary. Avoid over-engineering.
7. Design your system for scalability from the ground up.
8. Prefer horizontal scaling over vertical scaling for scalability.
9. Add Load Balancers to ensure high availability and distribute traffic.
10. Consider using SQL Databases for structured data and ACID transactions.
11. Opt for NoSQL Databases when dealing with unstructured data.
12. Use Database Sharding to scale SQL databases horizontally.
13. Use Database Indexing and search engines for efficient data retrievals.
14. Use Rate Limiting to prevent system overload and DOS attacks.
15. Use WebSockets for real-time communication.
16. Employ Heartbeat Mechanisms for failure detection.
17. Consider using a message queue for asynchronous communication.
18. Implement data partitioning and sharding for large datasets.
19. Consider denormalizing databases for read-heavy workloads.
20. Consider using event-driven architecture for decoupled systems.
21. Use CDNs to reduce latency for a global user base.
22. Use write-through cache for write-heavy applications.
23. Use read-through cache for read-heavy applications.
24. Use blob/object storage for storing media files like files, videos etc..
25. Implement Data Replication and Redundancy to avoid single point of failure.
26. Implement Autoscaling to handle traffic spikes smoothly.
27. Use Asynchronous processing to run background tasks.
28. Make operations idempotent where possible to simplify retry logic and error handling.
29. When appropriate, use microservices for flexibility, scalability, and maintainability.
30. Consider using a data lake or data warehouse for analytics and reporting.